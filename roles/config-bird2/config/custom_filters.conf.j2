# Custom filters for AS4242421080
{#
__        ___    ____  _   _ ___ _   _  ____ _
\ \      / / \  |  _ \| \ | |_ _| \ | |/ ___| |
 \ \ /\ / / _ \ | |_) |  \| || ||  \| | |  _| |
  \ V  V / ___ \|  _ <| |\  || || |\  | |_| |_|
   \_/\_/_/   \_\_| \_\_| \_|___|_| \_|\____(_)

__        ___    ____  _   _ ___ _   _  ____ _ _ _
\ \      / / \  |  _ \| \ | |_ _| \ | |/ ___| | | |
 \ \ /\ / / _ \ | |_) |  \| || ||  \| | |  _| | | |
  \ V  V / ___ \|  _ <| |\  || || |\  | |_| |_|_|_|
   \_/\_/_/   \_\_| \_\_| \_|___|_| \_|\____(_|_|_)

This file contains examples of custom route tweaks that I *happen to be using* on my network.
Many of these filters are designed specifically for my AS, and altogether they drastically alter the way that my network
processes dn42 routes.

In short, you are NOT meant to copy what's here. ESPECIALLY DON'T COPY PIECES YOU HAVEN'T TAKEN THE TIME TO UNDERSTAND YOURSELF!
If you just want BGP community support, look at community_filters.conf (it's based off the dn42 Wiki anyways)

#}
define OUTGOING_BGP_MED = {{ default_outgoing_bgp_med | default(0) }};

# Node ID is AS4242421080-specific and used for informational communities and route pinning. You probably don't need it
define NODEID = {{ ownip.rsplit('.', 1)[1] }};

define LC_ORIGIN_REGION = 101;
define LC_ORIGIN_DEPREF_CROSS_REGION = 102;
define LC_ORIGIN_NODEID = 103;
define LC_ORIGIN_REGION_TAG = 104;

# Subnets to route through iBGP
# This includes anycast services as well as any single-homed downstreams with agreement
define IBGP_NETS_4 = [172.23.0.53/32, 172.22.108.16/31+, 172.23.0.81/32];
define IBGP_NETS_6 = [fd42:d42:d42:53::/64, fd86:bad:11b7:1100::/56+, fd42:d42:d42:81::/64];

function is_ibgp_network() {
    if net.type = NET_IP4 && net ~ IBGP_NETS_4 then {
        return true;
    } else if net.type = NET_IP6 && net ~ IBGP_NETS_6 then {
        return true;
    } else {
        return false;
    }
}

# Subtract x from bgp_local_pref, while checking for underflow
function safe_lower_pref(int x) {
    if (bgp_local_pref > x) then {
        bgp_local_pref = bgp_local_pref - x;
    } else {
        bgp_local_pref = 0;
    }
}

# These are custom region tags which group together regions that aren't efficient
# (from my observations) to separate for cold potato routing
function get_region_tag(int dn42_region_tag) {
    if (dn42_region_tag = 44) then {
        return 1;  # North America - West
    } else if (dn42_region_tag ~ [42..43]) then {
        return 2;  # North America - Central/East
    } else if (dn42_region_tag = 41) then {
        return 3;  # Europe
    } else if (dn42_region_tag ~ [51..53]) then {
        return 4;  # Asia Pacific
    }
    return 0;
}

define COLD_POTATO_IGNORE = [
    0  # placeholder
];
function prefer_same_region_origin(int base_weight)
    int my_region_tag;
    int incoming_tag;
{
    # Cold potato routing: add local_pref += base_weight/(bgp_path.len) to routes originating in the same
    # region tag as the current node, or routes that don't have any region community set.
    #
    # Applying this policy to routes without a community region fixes cases when peers accidentally attach
    # region communities to routes in transit.
    # Without this, they will suck up all traffic for routes regardless of origin because everything
    # they export will appear to have the same region tag as the receiving node.
    #
    # Also, the local pref is based off BGP path length to allow more fine grained route tweaking:
    # e.g. steer transit traffic away from peer X unless all other paths have length >= 3
    my_region_tag = get_region_tag(DN42_REGION);
    incoming_tag = 0;
    bgp_large_community.add((OWNAS, LC_ORIGIN_REGION_TAG, my_region_tag));

    if (bgp_path.last ~ COLD_POTATO_IGNORE) then {
        return 0;
    }

    # TODO: replace this with native community extraction in Bird 2.0.9
    if ((64511, 41) ~ bgp_community) then {
        incoming_tag = get_region_tag(41);
    }
    else if ((64511, 42) ~ bgp_community) then {
        incoming_tag = get_region_tag(42);
    }
    else if ((64511, 43) ~ bgp_community) then {
        incoming_tag = get_region_tag(43);
    }
    else if ((64511, 44) ~ bgp_community) then {
        incoming_tag = get_region_tag(44);
    }
    else if ((64511, 50) ~ bgp_community) then {
        incoming_tag = get_region_tag(50);
    }
    else if ((64511, 51) ~ bgp_community) then {
        incoming_tag = get_region_tag(51);
    }
    else if ((64511, 52) ~ bgp_community) then {
        incoming_tag = get_region_tag(52);
    }
    else if ((64511, 53) ~ bgp_community) then {
        incoming_tag = get_region_tag(53);
    }

    if (incoming_tag = 0 || incoming_tag = my_region_tag) then {
        #print "Route ", net, " has incoming tag ", incoming_tag, " matching ours ", my_region_tag;
        bgp_local_pref = bgp_local_pref + 50;
    }
}

# Special cases I've added for route optimization, your mileage may vary
function handle_special_cases() {
    # Pin the following to EU:
    # - AS4242420101 / CCCDA
    # - AS65043 / ICVPN-DREILAENDERECK
    # - AS64654 / ChaosVPN
    if (DN42_REGION != 41 && bgp_path ~ [= * [4242420101, 65043, 64654] * =]) then {
        safe_lower_pref(20);
    }
    # 2022-03-17: prefer cold potato routing over densely connected autopeering transits
    if (bgp_path.len >= 2 && bgp_path ~ [= * [4242421588, 4242423914, 4242422717, 4242422189, 4242421817, 64719, 4201271111, 4242422980] * =]) then {
        safe_lower_pref(10);
    }
}

define ASES_REJECT = [
    0  # placeholder
];
function ebgp_import_filter()
    int my_region_tag;
{

    # Reject routes with unreasonable path lengths
    if (bgp_path.len > 12) then {
        reject;
    }
    bgp_local_pref = bgp_local_pref + 1400;
    safe_lower_pref(bgp_path.len * 100);

    if (bgp_path ~ [= * ASES_REJECT * =]) then {
        reject;
    }

    # Strip internal communities from incoming routes before processing
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_REGION, 41..53)]);
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_REGION_TAG, 0..5)]);
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_NODEID, 112..127)]);
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_NODEID, 33..39)]);

    handle_special_cases();
    prefer_same_region_origin(200);

    # Implement BLACKHOLE community as defined by RFC 7999
    # Based off https://bird.network.cz/pipermail/bird-users/2016-October/010705.html
    if (source = RTS_BGP && (65535, 666) ~ bgp_community) then {
        dest = RTD_BLACKHOLE;
    }

    # Informational communities: region of import & node ID of import
    bgp_large_community.add((OWNAS, LC_ORIGIN_REGION, DN42_REGION));
    bgp_large_community.add((OWNAS, LC_ORIGIN_NODEID, NODEID));
};

function ebgp_export_filter() {
    bgp_med = OUTGOING_BGP_MED;
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_REGION_TAG, 0..5)]);
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_DEPREF_CROSS_REGION, 1)]);

    # Informational communities: only node ID, as origin region uses standard dn42 community
    if (bgp_path.len = 0) then {
        bgp_large_community.add((OWNAS, LC_ORIGIN_NODEID, NODEID));
    }
    if source = RTS_STATIC then {
{% for region_tag in dn42_regions[1:] %}
        bgp_community.add((64511, {{ region_tag }}));
{% endfor %}
    }
};

function ibgp_import_filter()
    int my_region_tag;
{
    # Only process routes originating from BGP unless they're anycast networks
    if (source != RTS_BGP && !is_ibgp_network()) then {
        print "ibgp_import_filter: rejecting unknown prefix", net;
        reject;
    }

    if (bgp_path.len = 0) then {
        # Prefer locally originated iBGP routes, e.g. for anycast services
        bgp_local_pref = 2000;
    }

    my_region_tag = get_region_tag(DN42_REGION);
    if ((OWNAS, LC_ORIGIN_DEPREF_CROSS_REGION, 1) ~ bgp_large_community &&
        (OWNAS, LC_ORIGIN_REGION_TAG, my_region_tag) !~ bgp_large_community) then {
        safe_lower_pref(101);
    }

    accept;
}

function ibgp_export_filter() {
    if (source != RTS_BGP && !is_ibgp_network()) then {
        reject;
    }
    # Don't export device routes for dn42 anycast networks. These will be filled in via a static route config
    # triggered by service start/stop
    if (is_ibgp_network() && source = RTS_DEVICE) then {
        reject;
    }
    accept;
}
