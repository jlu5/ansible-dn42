#!/usr/bin/env python3
"""
Generate forward-zones and dnssec config for pdns-recursor.
"""

import argparse
import dataclasses
import ipaddress
import logging
import pathlib

import yaml

_OUT_FILENAME = 'dn42-zones.yml'
_CLEARNET_DNS_SERVERS=['1.1.1.1', '1.0.0.1', '8.8.8.8', '8.8.4.4']
_DN42_ZONES = [
    'dn42',
    # PTR zones
    '10.in-addr.arpa',
    '20.172.in-addr.arpa',
    '21.172.in-addr.arpa',
    '22.172.in-addr.arpa',
    '23.172.in-addr.arpa',
    '31.172.in-addr.arpa',
    'd.f.ip6.arpa'
]

@dataclasses.dataclass
class RegistryDNSEntry:
    nameservers: list[str]
    trust_anchors: list[str]

def _read_registry_dns_entry(path: pathlib.Path) -> RegistryDNSEntry:
    result = RegistryDNSEntry([], [])
    zone = path.name

    with open(path, encoding='utf-8') as f:
        for line in f.readlines():
            if line.startswith('nserver:'):
                nserver = line.split()[-1]
                if nserver.endswith('.ipv4.registry-sync.dn42'):
                    # 4.3.2.1.ipv4.registry-sync.dn42 -> 1.2.3.4
                    nserver = '.'.join(nserver.split('.')[3::-1])
                elif nserver.endswith('.ipv6.registry-sync.dn42'):
                    nserver_chars = nserver.split('.')[-4::-1]
                    nserver_chunks = [''.join(nserver_chars[i:i+4]) for i in range(0, len(nserver_chars), 4)]
                    nserver = ':'.join(nserver_chunks)

                try:
                    ipaddress.ip_address(nserver)
                except ValueError:
                    logging.warning('[%s] Could not parse nserver %r as IP, ignoring', zone, nserver)
                    continue
                result.nameservers.append(nserver)
            if line.startswith('ds-rdata'):
                ta = line.split(None, 1)[-1]
                result.trust_anchors.append(ta)
    return result

def generate(registry_path, outdir):
    registry_path = pathlib.Path(registry_path)

    dn42_delegation_servers = _read_registry_dns_entry(
        registry_path / 'data' / 'dns' / 'delegation-servers.dn42')
    assert dn42_delegation_servers.nameservers

    conf = {
        'recursor':{
            'forward_zones_recurse': [
                {
                    'zone': '.',
                    'forwarders': _CLEARNET_DNS_SERVERS
                }
            ],
            'forward_zones': [
                {
                    'zone': zone,
                    'forwarders': dn42_delegation_servers.nameservers
                }
                for zone in _DN42_ZONES
            ]
        }
    }
    forward_zones = conf['recursor']['forward_zones']

    # Read external zones
    for dns_entry_path in registry_path.glob('data/dns/*'):
        zone = dns_entry_path.name
        if '.' in zone and not zone.endswith('.arpa'):  # not a TLD
            continue
        if zone == 'dn42':
            dns_entry_path = dns_entry_path.parent / 'delegation-servers.dn42'

        entry = _read_registry_dns_entry(dns_entry_path)
        if entry.nameservers:
            forward_zones.append({
                'zone': zone,
                'forwarders': entry.nameservers
            })
            logging.info('[%s] forwarders=%s', zone, entry.nameservers)
        else:
            logging.warning('[%s] No valid forwarders found, skipping', zone)

    outf = outdir / _OUT_FILENAME
    with open(outf, 'w', encoding='utf8') as f:
        f.write('# Autogenerated, do not edit!\n')
        yaml.dump(conf, f)

    return conf

def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-v", '--verbose', help="enable verbose logging", action='store_true')
    parser.add_argument("registry_path", help="path to dn42 registry Git repo", type=pathlib.Path)
    parser.add_argument("outdir", help="path to write output files", type=pathlib.Path)
    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.WARNING)

    generate(args.registry_path, args.outdir)

if __name__ == '__main__':
    main()
